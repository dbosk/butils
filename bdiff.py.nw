\documentclass[a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[swedish,british]{babel}

\usepackage{noweb}
\def\nwendcode{\endtrivlist \endgroup}
\let\nwdocspar=\smallbreak

\usepackage{authblk}
\usepackage{varioref}
\usepackage[hidelinks]{hyperref}
\usepackage[capitalize]{cleveref}
\usepackage{eurosym}

\usepackage[natbib,style=alphabetic,maxbibnames=99]{biblatex}
\addbibresource{bdiff.bib}

\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amssymb}
\theoremstyle{definition}
\newtheorem{example}{Example}

\usepackage{listings}
\lstset{%
  literate=%
    {Ö}{{\"O}}1
    {Ä}{{\"A}}1
    {Å}{{\AA}}1
    {å}{{\aa}}1
    {ä}{{\"a}}1
    {ö}{{\"o}}1
    {é}{{\'e}}1
    {è}{{\`e}}1,
  language=,
  numbers=left,
  stepnumber=1,
  escapeinside={*@}{@*}
}

\usepackage[defblank]{paralist}

\title{%
  bdiff: A diff-like utility for account reports
}
\author{%
  Daniel Bosk
  \and
  Mitra Damghanian
}
%\affil{%
%  \texttt{\href{http://daniel.bosk.se}{http://daniel.bosk.se}}
%}
\date{\today}


\begin{document}
\maketitle
\begin{abstract}
We want to find differences between double-entry book-keeping reports that 
should be synchronized, e.g.\ a bank statement and a budget.
We solve this problem by abstracting the relevant data in the reports and using 
a diff-like algorithm to find the differences.
Due to the inexact matches that has to be made we use fuzzy comparisons.
\end{abstract}

\tableofcontents
\clearpage
@


\section{Introduction}
\label{Introduction}

We want to compare statements from different double-entry book-keeping systems 
to be able to sync them, e.g.\ a bank statement and a budget.
The data we are interested in are thus credits and debits.
We are not interested in the relative ordering, but rather to match individual 
statements.

\begin{example}\label{MatchingEntries}
We have two bank statements:
\begin{lstlisting}
2016-01-23 G20                -15.00 EUR
2016-01-23 Marché des Lices   -10.00 EUR
2016-01-24 G20                -5.00 EUR
\end{lstlisting}
and
\begin{lstlisting}
2016-01-25 MARCHEE DES LIC    -10.00 EUR
2016-01-25 G20 CESSON         -15.00 EUR
2016-01-26 G20 CESSON         -5.00 EUR
\end{lstlisting}
However, one is manually documented in the budget and has the dates on the 
receipts (the top one), whereas the other is what is documented by the bank due 
to their processing of payments (bottom one).
Hence, the names and dates are not exactly the same, but a human can still 
infer that they match.
\end{example}

We want to capture this matching possibility algorithmically.
The main purpose of this program is to identify places where these two 
statements differ.

\begin{example}\label{UnmatchingEntries}
Consider the following two two bank statements:
\begin{lstlisting}
2016-01-23 G20                -15.00 EUR
2016-01-23 Marché des Lices   -10.00 EUR
2016-01-24 G20                -5.00 EUR
\end{lstlisting}
and
\begin{lstlisting}[firstnumber=0]
2016-01-22 BRIVIN             -3.00 EUR
2016-01-25 MARCHEE DES LIC    -10.00 EUR
2016-01-25 G20 CESSON         -15.00 EUR
2016-01-26 G20 CESSON         -5.00 EUR
\end{lstlisting}
We see that the first line is new from \cref{MatchingEntries}, and also that 
this line has no matching.
\end{example}


\subsection{Program structure}
\label{SrcStructure}

We are implementing this program in Python 3.
The main file is [[<<bdiff.py>>]] and it is structured as follows:
<<bdiff.py>>=
<<imports>>
<<functions>>
<<classes>>

def main(argv):
  <<main body>>

if __name__ == "__main__":
  sys.exit(main(sys.argv))
@

Due to this we have to add the [[sys]] module from Python:
<<imports>>=
import sys
@


\section{Data structure}
\label{DataStructure}

As we can see in \cref{MatchingEntries,UnmatchingEntries}, we can use the 
amount and perhaps parts of the other data for making matchings.
We will define an abstract data type for a statement line, containing either 
a credit or a debit.
Then we will have a factory object~\cite{DesignPatterns} create these abstract 
statement lines.
We need one factory per type of file we support, e.g.\ one for Swedbank's 
exported statements and one for Credit Agricole's.
Once we have two lists of abstract statements, we can pass them on to the 
comparison algorithm in \cref{MatchingAlgorithm}.

\subsection{An abstract representation}
\label{AbstractRepresentation}

The minimum of attributes we need in the representation of an entry in an 
account report is:
\begin{inparablank}
\item date,
\item description, and
\item value.
\end{inparablank}
We will implement the entries as instantiations of a class [[Entry]]:
<<classes>>=
class Entry:
  <<Entry methods>>
@ We will need a constructor which initialized all the required attributes from 
given arguments:
<<Entry methods>>=
def __init__(self, date, desc, value):
  self.date = date
  self.desc = desc
  self.value = value
@

We will further need overloaded methods for some operations.
We will start with equality, two entries are equal if all attributes are equal:
<<Entry methods>>=
def __eq__(self, other):
  return ( self.date == other.date and
    self.desc == other.desc and
    self.value == other.value )
@

Next we would like the ability to sort the entries.
For this we should implement the [[__lt__]] method.
We want to sort first on the dates, then on the description and lastly on the 
value.
To do this we simply compare the attributes in the correct order:
<<sort two entries>>=
if self.date == other.date:
  if self.desc == other.desc:
    return self.value < other.value
  return self.desc < other.desc
return self.date < other.date
@

Finally, we also need to compare similar but not equal entries, as in 
\cref{MatchingEntries}.
We will do this by computing the distance between the two entries.
We will define a method here, but describe its implementation
([[<<compute distance for two entries>>]]) in \cref{MatchingAlgorithm}.
<<Entry methods>>=
def distance(self, other):
  <<compute Entry distance for two entries>>
  <<return Entry distance>>
@

\subsection{Parsing Ledger reports}
\label{ParsingLedger}

We want to be able to parse the reports of the register command of the Ledger 
utility~\cite{Ledger}.

\subsection{Parsing Swedbank reports}
\label{ParsingSwedbank}

Swedbank allows exporting the bank statement in different formats.

\subsection{Parsing CA reports}
\label{ParsingCA}

Credit Agricole allows exporting of bank statements in different formats.


\section{A fuzzy matchmaking algorithm}
\label{MatchingAlgorithm}

We want to design an algorithm that can capture the matching outlined in 
\cref{MatchingEntries,UnmatchingEntries} above.
We will first implement a metric for how well two entries match.
Will will do this by defining a distance between them,
[[<<compute Entry distance for two entries>>]] mentioned above.
The next step is to match entries in one left-hand-side report (a list) against 
entries in another right-hand-side report (list).
The result is a matching matrix where the rows are entries from the 
left-hand-side list and the columns are entries in the right-hand-side list.  
Basically, the minimums for rows and columns are the best matchings.

\subsection{Distance between entries}

The distance is the sum of the distances between its components, i.e.\ the 
attributes.
<<return Entry distance>>=
return distance_date + distance_desc + distance_val
@ This way the two entries are equal if they get the distance 0, i.e.\ if all 
the attributes have distance 0 and are thus equal.
Possibly it is interesting to weight the different components, but this might 
require some measurements to determine.

The components are computed as follows.
The distance between the values is the absolute value of their arithmetic 
difference.
<<compute Entry distance for two entries>>=
distance_value = math.abs(self.value - other.value)
@ This also requires the [[math]] module:
<<imports>>=
import math
@

The distance between the dates is the difference in days.
<<compute Entry distance for two entries>>=
distance_date = math.abs(self.date - other.date)
@

The distance between the descriptions is a bit more complex.
We want the distance to be case insensitive, e.g.: usually the names in 
Swedbank's descriptions are all upper case, whereas entries in Ledger are 
capitalized or lower case.
Further, the entries in Ledger are usually shorter than those in Swedbank or 
CA, e.g.: the entry in Ledger will read \enquote{KFC} whereas it will read 
\enquote{KFC CESSON} in CA.
Based on this, if one is a sub-string of the other, the distance should be 0:
<<compute Entry distance for two entries>>=
if self.desc in other.desc or other.desc in self.desc:
  distance_desc = 0
else:
  <<compute distance of descriptions>>
@

\subsection{A distance matrix}

\dots



\section*{Acknowledgements}

This code is available under the following BSD license:
\begin{quote}
  \input{LICENSE}
\end{quote}


\printbibliography{}
\end{document}
